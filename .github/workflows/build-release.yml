name: Build & Release Bundle

on:
  push:
    branches: [dev]
    paths:
      - "src-tauri/Cargo.toml" # Triggered by version bump
  workflow_dispatch:
    inputs:
      skip_build:
        description: "Skip build and use exe from previous release (for dependency-only updates)"
        required: false
        default: false
        type: boolean

env:
  CARGO_TERM_COLOR: always

jobs:
  merge-to-main:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Merge dev to main
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin
          # Force-push dev to main (dev is source of truth)
          git push origin origin/dev:main --force

  build:
    needs: merge-to-main
    runs-on: windows-latest
    permissions:
      contents: write

    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Get version from Cargo.toml
        id: version
        shell: pwsh
        run: |
          $cargo = Get-Content src-tauri/Cargo.toml -Raw
          if ($cargo -match 'version\s*=\s*"([^"]+)"') {
            $version = $matches[1]
            echo "VERSION=$version" >> $env:GITHUB_OUTPUT
            echo "Found version: $version"
          } else {
            echo "Could not find version in Cargo.toml"
            exit 1
          }

      - name: Check if release already exists
        id: check_release
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $releases = gh release list --limit 100 --json tagName | ConvertFrom-Json
          $exists = $releases | Where-Object { $_.tagName -eq "v$version" }
          if ($exists) {
            echo "RELEASE_EXISTS=true" >> $env:GITHUB_OUTPUT
            echo "Release v$version already exists, skipping..."
          } else {
            echo "RELEASE_EXISTS=false" >> $env:GITHUB_OUTPUT
            echo "Release v$version does not exist, will create"
          }
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        uses: actions/setup-node@v6
        with:
          node-version: "20"
          cache: "npm"

      - name: Setup Rust
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        uses: swatinem/rust-cache@v2
        with:
          workspaces: "./src-tauri -> target"
          cache-on-failure: true
          shared-key: "rust-build"

      - name: Install dependencies
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        run: npm ci

      - name: Build Analytics Dashboard
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false' && inputs.skip_build != 'true'
        shell: pwsh
        run: |
          echo "Building analytics dashboard..."
          cd analytics-dashboard
          npm ci
          npm run build
          cd ..
          echo "Analytics dashboard built to analytics-dashboard/dist"
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}

      - name: Install Tauri CLI (cached)
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        shell: pwsh
        run: |
          # Check if tauri-cli is already installed
          $tauriVersion = npm list @tauri-apps/cli 2>$null
          if ($tauriVersion) {
            echo "Tauri CLI already installed"
          } else {
            echo "Installing Tauri CLI..."
            npm install @tauri-apps/cli
          }

      - name: Pre-install WiX Toolset
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        shell: pwsh
        run: |
          # Pre-download WiX to avoid timeout during Tauri build
          $wixDir = "$env:LOCALAPPDATA\tauri\WixTools"

          if (Test-Path $wixDir) {
            echo "WiX Toolset already cached"
          } else {
            echo "Downloading WiX Toolset..."
            New-Item -ItemType Directory -Force -Path $wixDir | Out-Null
            
            # Download with retry and increased timeout
            $wixUrl = "https://github.com/wixtoolset/wix3/releases/download/wix3141rtm/wix314-binaries.zip"
            $wixZip = "$env:TEMP\wix314-binaries.zip"
            
            $webClient = New-Object System.Net.WebClient
            $retries = 3
            $success = $false
            
            for ($i = 1; $i -le $retries; $i++) {
              try {
                echo "Download attempt $i of $retries..."
                $webClient.DownloadFile($wixUrl, $wixZip)
                $success = $true
                break
              } catch {
                echo "Attempt $i failed: $_"
                if ($i -lt $retries) {
                  Start-Sleep -Seconds 5
                }
              }
            }
            
            if (-not $success) {
              echo "Failed to download WiX after $retries attempts"
              exit 1
            }
            
            echo "Extracting WiX Toolset..."
            Expand-Archive -Path $wixZip -DestinationPath $wixDir -Force
            Remove-Item $wixZip -Force
            
            echo "WiX Toolset installed to: $wixDir"
          }

          # Verify WiX installation
          if (Test-Path "$wixDir\candle.exe") {
            echo "WiX Toolset verified successfully"
          } else {
            echo "WiX Toolset verification failed"
            exit 1
          }

      - name: Build Tauri app
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false' && inputs.skip_build != 'true'
        shell: pwsh
        run: npm run tauri build
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}
          VITE_ADMIN_USER_ID: ${{ secrets.VITE_ADMIN_USER_ID }}

      - name: Download StreamNook.exe from previous release (skip_build mode)
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false' && inputs.skip_build == 'true'
        shell: pwsh
        run: |
          # Get the latest release
          $latestRelease = gh release view --json assets,tagName | ConvertFrom-Json
          echo "Latest release: $($latestRelease.tagName)"

          # Find the exe or bundle
          $exeAsset = $latestRelease.assets | Where-Object { $_.name -like "*.exe" -or $_.name -eq "StreamNook.7z" }
          if ($exeAsset) {
            echo "Downloading: $($exeAsset.name)"
            gh release download $latestRelease.tagName -p $exeAsset.name -D ./previous-release
          } else {
            echo "No exe found in previous release"
            exit 1
          }
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get latest Streamlink portable version
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        id: streamlink
        shell: pwsh
        run: |
          # Get latest release from streamlink windows-builds (authenticated to avoid rate limits)
          $headers = @{
            "Authorization" = "Bearer $env:GH_TOKEN"
            "Accept" = "application/vnd.github+json"
            "X-GitHub-Api-Version" = "2022-11-28"
          }
          $release = Invoke-RestMethod -Uri "https://api.github.com/repos/streamlink/windows-builds/releases/latest" -Headers $headers
          $version = $release.tag_name
          echo "STREAMLINK_VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "Latest Streamlink version: $version"

          # Find the zip asset (the portable distribution)
          # Try to find x86_64 zip first, then fallback to any zip
          $asset = $release.assets | Where-Object { $_.name -like "*x86_64.zip" } | Select-Object -First 1
          if (-not $asset) {
            # Fallback to any zip that's not an installer
            $asset = $release.assets | Where-Object { $_.name -like "*.zip" -and $_.name -notlike "*installer*" } | Select-Object -First 1
          }

          if ($asset) {
            echo "STREAMLINK_URL=$($asset.browser_download_url)" >> $env:GITHUB_OUTPUT
            echo "STREAMLINK_ASSET=$($asset.name)" >> $env:GITHUB_OUTPUT
            echo "Found asset: $($asset.name)"
          } else {
            echo "No streamlink zip found"
            echo "Available assets:"
            $release.assets | ForEach-Object { echo "  - $($_.name)" }
            exit 1
          }
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get latest TTV LOL plugin version
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        id: ttvlol
        shell: pwsh
        run: |
          # Get latest release from streamlink-ttvlol (authenticated to avoid rate limits)
          $headers = @{
            "Authorization" = "Bearer $env:GH_TOKEN"
            "Accept" = "application/vnd.github+json"
            "X-GitHub-Api-Version" = "2022-11-28"
          }
          $release = Invoke-RestMethod -Uri "https://api.github.com/repos/2bc4/streamlink-ttvlol/releases/latest" -Headers $headers
          $version = $release.tag_name
          echo "TTVLOL_VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "Latest TTV LOL version: $version"

          # Find twitch.py asset
          $asset = $release.assets | Where-Object { $_.name -eq "twitch.py" }
          if ($asset) {
            echo "TTVLOL_URL=$($asset.browser_download_url)" >> $env:GITHUB_OUTPUT
            echo "Found twitch.py"
          } else {
            echo "twitch.py not found in release"
            exit 1
          }
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Download Streamlink portable
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path ./bundle/streamlink
          $url = "${{ steps.streamlink.outputs.STREAMLINK_URL }}"
          $outFile = "./streamlink-portable.zip"
          echo "Downloading: $url"
          Invoke-WebRequest -Uri $url -OutFile $outFile

          # Extract
          Expand-Archive -Path $outFile -DestinationPath ./bundle/streamlink-temp -Force

          # Move contents (handle nested folder structure)
          $extracted = Get-ChildItem ./bundle/streamlink-temp -Directory | Select-Object -First 1
          if ($extracted) {
            Move-Item "$($extracted.FullName)/*" ./bundle/streamlink/ -Force
          } else {
            Move-Item ./bundle/streamlink-temp/* ./bundle/streamlink/ -Force
          }

          Remove-Item ./bundle/streamlink-temp -Recurse -Force
          Remove-Item $outFile -Force

          # Create plugins directory
          New-Item -ItemType Directory -Force -Path ./bundle/streamlink/plugins

          echo "Streamlink extracted to ./bundle/streamlink"

      - name: Download TTV LOL plugin
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        shell: pwsh
        run: |
          $url = "${{ steps.ttvlol.outputs.TTVLOL_URL }}"
          echo "Downloading: $url"
          Invoke-WebRequest -Uri $url -OutFile ./bundle/streamlink/plugins/twitch.py
          echo "TTV LOL plugin downloaded to ./bundle/streamlink/plugins/twitch.py"

      - name: Copy StreamNook.exe to bundle
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        shell: pwsh
        run: |
          if ("${{ inputs.skip_build }}" -eq "true") {
            # Use exe from previous release
            $exe = Get-ChildItem ./previous-release -Filter "*.exe" | Select-Object -First 1
            if ($exe) {
              Copy-Item $exe.FullName ./bundle/StreamNook.exe
            } else {
              # Extract from previous bundle
              $bundle = Get-ChildItem ./previous-release -Filter "StreamNook.7z" | Select-Object -First 1
              if ($bundle) {
                7z x $bundle.FullName -o"./previous-release/extracted"
                Copy-Item ./previous-release/extracted/StreamNook.exe ./bundle/
              }
            }
          } else {
            # Use freshly built exe
            Copy-Item src-tauri/target/release/StreamNook.exe ./bundle/
          }
          echo "StreamNook.exe copied to bundle"

      - name: Copy CHANGELOG.md to bundle
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        shell: pwsh
        run: |
          Copy-Item CHANGELOG.md ./bundle/
          echo "CHANGELOG.md copied to bundle"
          # Note: Analytics dashboard is now embedded directly in the exe via rust-embed
          # No separate resources folder needed

      - name: Generate components.json
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $streamlinkVersion = "${{ steps.streamlink.outputs.STREAMLINK_VERSION }}"
          $ttvlolVersion = "${{ steps.ttvlol.outputs.TTVLOL_VERSION }}"
          $buildDate = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")

          $components = @{
            schema_version = 1
            streamnook = @{
              version = $version
              build_date = $buildDate
            }
            components = @{
              streamlink = @{
                version = $streamlinkVersion
                source_url = "https://github.com/streamlink/windows-builds/releases"
              }
              ttvlol = @{
                version = $ttvlolVersion
                source_url = "https://github.com/2bc4/streamlink-ttvlol/releases"
              }
            }
          }

          $json = $components | ConvertTo-Json -Depth 10
          $json | Out-File -FilePath ./bundle/components.json -Encoding utf8
          echo "components.json created:"
          echo $json

      - name: Create 7z bundle
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        shell: pwsh
        run: |
          $bundleName = "StreamNook.7z"

          # Create 7z archive with maximum compression
          cd bundle
          7z a -t7z -mx=9 "../$bundleName" *
          cd ..

          echo "BUNDLE_NAME=$bundleName" >> $env:GITHUB_OUTPUT
          echo "Created: $bundleName"

          # Show bundle size
          $size = (Get-Item $bundleName).Length / 1MB
          echo "Bundle size: $([math]::Round($size, 2)) MB"
        id: bundle

      - name: Generate checksums
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        shell: pwsh
        run: |
          $bundleName = "${{ steps.bundle.outputs.BUNDLE_NAME }}"
          $hash = (Get-FileHash $bundleName -Algorithm SHA256).Hash
          "$hash  $bundleName" | Out-File -FilePath checksums.txt -Encoding utf8
          echo "Checksums generated:"
          Get-Content checksums.txt

      - name: Extract changelog for this version
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        id: changelog
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $changelog = Get-Content CHANGELOG.md -Raw

          # Try to extract section for this version
          $pattern = "(?s)## \[?$version\]?.*?(?=## \[|\z)"
          if ($changelog -match $pattern) {
            $section = $matches[0].Trim()
            # Write to temp file for use in release step
            $section | Out-File -FilePath ./changelog_section.md -Encoding utf8
            echo "Found changelog section for v$version"
          } else {
            "Release v$version" | Out-File -FilePath ./changelog_section.md -Encoding utf8
            echo "No changelog section found, using default"
          }

      - name: Create GitHub Release
        if: steps.check_release.outputs.RELEASE_EXISTS == 'false'
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $bundleName = "${{ steps.bundle.outputs.BUNDLE_NAME }}"
          $streamlinkVersion = "${{ steps.streamlink.outputs.STREAMLINK_VERSION }}"
          $ttvlolVersion = "${{ steps.ttvlol.outputs.TTVLOL_VERSION }}"

          # Read changelog section from temp file
          $changelogSection = Get-Content ./changelog_section.md -Raw

          # Build component info section using simple string array
          $lines = @()
          $lines += ""
          $lines += "---"
          $lines += ""
          $lines += "### Bundle Components"
          $lines += "- **StreamNook**: v$version"
          $lines += "- **Streamlink**: $streamlinkVersion"
          $lines += "- **TTV LOL Plugin**: $ttvlolVersion"
          $lines += ""
          $lines += "### Installation"
          $lines += "1. Download ``$bundleName``"
          $lines += "2. Extract the .7z file"
          $lines += "3. Run ``StreamNook.exe``"
          $lines += "4. The app will automatically set up Streamlink and TTV LOL on first run"

          $componentInfo = $lines -join "`n"
          $notes = $changelogSection + $componentInfo

          # Write to file for gh release
          $notes | Out-File -FilePath ./release_notes.md -Encoding utf8

          gh release create "v$version" --title "StreamNook v$version" --notes-file ./release_notes.md "$bundleName" "bundle/components.json" "checksums.txt"

          echo "Release v$version created!"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
